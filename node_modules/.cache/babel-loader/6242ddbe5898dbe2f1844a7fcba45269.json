{"ast":null,"code":"const binding = require('bindings')('bindings.node');\n\nconst AbstractBinding = require('@serialport/binding-abstract');\n\nconst _require = require('util'),\n      promisify = _require.promisify;\n\nconst serialNumParser = require('./win32-sn-parser');\n\nconst asyncList = promisify(binding.list);\nconst asyncOpen = promisify(binding.open);\nconst asyncClose = promisify(binding.close);\nconst asyncRead = promisify(binding.read);\nconst asyncWrite = promisify(binding.write);\nconst asyncUpdate = promisify(binding.update);\nconst asyncSet = promisify(binding.set);\nconst asyncGet = promisify(binding.get);\nconst asyncGetBaudRate = promisify(binding.getBaudRate);\nconst asyncDrain = promisify(binding.drain);\nconst asyncFlush = promisify(binding.flush);\n\nconst _require2 = require('./legacy'),\n      wrapWithHiddenComName = _require2.wrapWithHiddenComName;\n/**\n * The Windows binding layer\n */\n\n\nclass WindowsBinding extends AbstractBinding {\n  static async list() {\n    const ports = await asyncList(); // Grab the serial number from the pnp id\n\n    return wrapWithHiddenComName(ports.map(port => {\n      if (port.pnpId && !port.serialNumber) {\n        const serialNumber = serialNumParser(port.pnpId);\n\n        if (serialNumber) {\n          return { ...port,\n            serialNumber\n          };\n        }\n      }\n\n      return port;\n    }));\n  }\n\n  constructor(opt) {\n    super(opt);\n    this.bindingOptions = { ...opt.bindingOptions\n    };\n    this.fd = null;\n    this.writeOperation = null;\n  }\n\n  get isOpen() {\n    return this.fd !== null;\n  }\n\n  async open(path, options) {\n    await super.open(path, options);\n    this.openOptions = { ...this.bindingOptions,\n      ...options\n    };\n    const fd = await asyncOpen(path, this.openOptions);\n    this.fd = fd;\n  }\n\n  async close() {\n    await super.close();\n    const fd = this.fd;\n    this.fd = null;\n    return asyncClose(fd);\n  }\n\n  async read(buffer, offset, length) {\n    await super.read(buffer, offset, length);\n\n    try {\n      const bytesRead = await asyncRead(this.fd, buffer, offset, length);\n      return {\n        bytesRead,\n        buffer\n      };\n    } catch (err) {\n      if (!this.isOpen) {\n        err.canceled = true;\n      }\n\n      throw err;\n    }\n  }\n\n  async write(buffer) {\n    this.writeOperation = super.write(buffer).then(async () => {\n      if (buffer.length === 0) {\n        return;\n      }\n\n      await asyncWrite(this.fd, buffer);\n      this.writeOperation = null;\n    });\n    return this.writeOperation;\n  }\n\n  async update(options) {\n    await super.update(options);\n    return asyncUpdate(this.fd, options);\n  }\n\n  async set(options) {\n    await super.set(options);\n    return asyncSet(this.fd, options);\n  }\n\n  async get() {\n    await super.get();\n    return asyncGet(this.fd);\n  }\n\n  async getBaudRate() {\n    await super.get();\n    return asyncGetBaudRate(this.fd);\n  }\n\n  async drain() {\n    await super.drain();\n    await this.writeOperation;\n    return asyncDrain(this.fd);\n  }\n\n  async flush() {\n    await super.flush();\n    return asyncFlush(this.fd);\n  }\n\n}\n\nmodule.exports = WindowsBinding;","map":null,"metadata":{},"sourceType":"script"}