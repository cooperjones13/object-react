{"ast":null,"code":"const debug = require('debug');\n\nconst logger = debug('serialport/bindings/poller');\n\nconst EventEmitter = require('events');\n\nconst PollerBindings = require('bindings')('bindings.node').Poller;\n\nconst EVENTS = {\n  UV_READABLE: 0b0001,\n  UV_WRITABLE: 0b0010,\n  UV_DISCONNECT: 0b0100\n};\n\nfunction handleEvent(error, eventFlag) {\n  if (error) {\n    logger('error', error);\n    this.emit('readable', error);\n    this.emit('writable', error);\n    this.emit('disconnect', error);\n    return;\n  }\n\n  if (eventFlag & EVENTS.UV_READABLE) {\n    logger('received \"readable\"');\n    this.emit('readable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_WRITABLE) {\n    logger('received \"writable\"');\n    this.emit('writable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_DISCONNECT) {\n    logger('received \"disconnect\"');\n    this.emit('disconnect', null);\n  }\n}\n/**\n * Polls unix systems for readable or writable states of a file or serialport\n */\n\n\nclass Poller extends EventEmitter {\n  constructor(fd, FDPoller = PollerBindings) {\n    logger('Creating poller');\n    super();\n    this.poller = new FDPoller(fd, handleEvent.bind(this));\n  }\n  /**\n   * Wait for the next event to occur\n   * @param {string} event ('readable'|'writable'|'disconnect')\n   * @returns {Poller} returns itself\n   */\n\n\n  once(event, callback) {\n    switch (event) {\n      case 'readable':\n        this.poll(EVENTS.UV_READABLE);\n        break;\n\n      case 'writable':\n        this.poll(EVENTS.UV_WRITABLE);\n        break;\n\n      case 'disconnect':\n        this.poll(EVENTS.UV_DISCONNECT);\n        break;\n    }\n\n    return super.once(event, callback);\n  }\n  /**\n   * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use\n   * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.\n   * @returns {undefined}\n   */\n\n\n  poll(eventFlag) {\n    eventFlag = eventFlag || 0;\n\n    if (eventFlag & EVENTS.UV_READABLE) {\n      logger('Polling for \"readable\"');\n    }\n\n    if (eventFlag & EVENTS.UV_WRITABLE) {\n      logger('Polling for \"writable\"');\n    }\n\n    if (eventFlag & EVENTS.UV_DISCONNECT) {\n      logger('Polling for \"disconnect\"');\n    }\n\n    this.poller.poll(eventFlag);\n  }\n  /**\n   * Stop listening for events and cancel all outstanding listening with an error\n   * @returns {undefined}\n   */\n\n\n  stop() {\n    logger('Stopping poller');\n    this.poller.stop();\n    this.emitCanceled();\n  }\n\n  destroy() {\n    logger('Destroying poller');\n    this.poller.destroy();\n    this.emitCanceled();\n  }\n\n  emitCanceled() {\n    const err = new Error('Canceled');\n    err.canceled = true;\n    this.emit('readable', err);\n    this.emit('writable', err);\n    this.emit('disconnect', err);\n  }\n\n}\n\nPoller.EVENTS = EVENTS;\nmodule.exports = Poller;","map":null,"metadata":{},"sourceType":"script"}