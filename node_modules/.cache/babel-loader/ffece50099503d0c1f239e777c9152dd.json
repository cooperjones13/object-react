{"ast":null,"code":"const _require = require('stream'),\n      Transform = _require.Transform;\n/**\n * A transform stream that uses a regular expression to split the incoming text upon.\n *\n * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Regex = require('@serialport/parser-regex')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Regex({ regex: /[\\r\\n]+/ }))\nparser.on('data', console.log)\n */\n\n\nclass RegexParser extends Transform {\n  constructor(options) {\n    const opts = {\n      encoding: 'utf8',\n      ...options\n    };\n\n    if (opts.regex === undefined) {\n      throw new TypeError('\"options.regex\" must be a regular expression pattern or object');\n    }\n\n    if (!(opts.regex instanceof RegExp)) {\n      opts.regex = new RegExp(opts.regex);\n    }\n\n    super(opts);\n    this.regex = opts.regex;\n    this.data = '';\n  }\n\n  _transform(chunk, encoding, cb) {\n    const data = this.data + chunk;\n    const parts = data.split(this.regex);\n    this.data = parts.pop();\n    parts.forEach(part => {\n      this.push(part);\n    });\n    cb();\n  }\n\n  _flush(cb) {\n    this.push(this.data);\n    this.data = '';\n    cb();\n  }\n\n}\n\nmodule.exports = RegexParser;","map":null,"metadata":{},"sourceType":"script"}