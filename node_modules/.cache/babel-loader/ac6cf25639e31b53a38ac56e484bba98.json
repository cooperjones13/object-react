{"ast":null,"code":"const _require = require('util'),\n      promisify = _require.promisify;\n\nconst binding = require('bindings')('bindings.node');\n\nconst AbstractBinding = require('@serialport/binding-abstract');\n\nconst linuxList = require('./linux-list');\n\nconst Poller = require('./poller');\n\nconst unixRead = require('./unix-read');\n\nconst unixWrite = require('./unix-write');\n\nconst _require2 = require('./legacy'),\n      wrapWithHiddenComName = _require2.wrapWithHiddenComName;\n\nconst defaultBindingOptions = Object.freeze({\n  vmin: 1,\n  vtime: 0\n});\nconst asyncOpen = promisify(binding.open);\nconst asyncClose = promisify(binding.close);\nconst asyncUpdate = promisify(binding.update);\nconst asyncSet = promisify(binding.set);\nconst asyncGet = promisify(binding.get);\nconst asyncGetBaudRate = promisify(binding.getBaudRate);\nconst asyncDrain = promisify(binding.drain);\nconst asyncFlush = promisify(binding.flush);\n/**\n * The linux binding layer\n */\n\nclass LinuxBinding extends AbstractBinding {\n  static list() {\n    return wrapWithHiddenComName(linuxList());\n  }\n\n  constructor(opt) {\n    super(opt);\n    this.bindingOptions = { ...defaultBindingOptions,\n      ...opt.bindingOptions\n    };\n    this.fd = null;\n    this.writeOperation = null;\n  }\n\n  get isOpen() {\n    return this.fd !== null;\n  }\n\n  async open(path, options) {\n    await super.open(path, options);\n    this.openOptions = { ...this.bindingOptions,\n      ...options\n    };\n    const fd = await asyncOpen(path, this.openOptions);\n    this.fd = fd;\n    this.poller = new Poller(fd);\n  }\n\n  async close() {\n    await super.close();\n    const fd = this.fd;\n    this.poller.stop();\n    this.poller.destroy();\n    this.poller = null;\n    this.openOptions = null;\n    this.fd = null;\n    return asyncClose(fd);\n  }\n\n  async read(buffer, offset, length) {\n    await super.read(buffer, offset, length);\n    return unixRead.call(this, buffer, offset, length);\n  }\n\n  async write(buffer) {\n    this.writeOperation = super.write(buffer).then(async () => {\n      if (buffer.length === 0) {\n        return;\n      }\n\n      await unixWrite.call(this, buffer);\n      this.writeOperation = null;\n    });\n    return this.writeOperation;\n  }\n\n  async update(options) {\n    await super.update(options);\n    return asyncUpdate(this.fd, options);\n  }\n\n  async set(options) {\n    await super.set(options);\n    return asyncSet(this.fd, options);\n  }\n\n  async get() {\n    await super.get();\n    return asyncGet(this.fd);\n  }\n\n  async getBaudRate() {\n    await super.get();\n    return asyncGetBaudRate(this.fd);\n  }\n\n  async drain() {\n    await super.drain();\n    await this.writeOperation;\n    return asyncDrain(this.fd);\n  }\n\n  async flush() {\n    await super.flush();\n    return asyncFlush(this.fd);\n  }\n\n}\n\nmodule.exports = LinuxBinding;","map":null,"metadata":{},"sourceType":"script"}