{"ast":null,"code":"const fs = require('fs');\n\nconst debug = require('debug');\n\nconst logger = debug('serialport/bindings/unixRead');\n\nconst _require = require('util'),\n      promisify = _require.promisify;\n\nconst readAsync = promisify(fs.read);\n\nconst readable = binding => {\n  return new Promise((resolve, reject) => {\n    binding.poller.once('readable', err => err ? reject(err) : resolve());\n  });\n};\n\nmodule.exports = async function unixRead(buffer, offset, length) {\n  logger('Starting read');\n\n  if (!this.isOpen) {\n    throw new Error('Port is not open');\n  }\n\n  try {\n    const _ref = await readAsync(this.fd, buffer, offset, length, null),\n          bytesRead = _ref.bytesRead;\n\n    if (bytesRead === 0) {\n      return this.read(buffer, offset, length);\n    }\n\n    logger('Finished read', bytesRead, 'bytes');\n    return {\n      bytesRead,\n      buffer\n    };\n  } catch (err) {\n    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n      if (!this.isOpen) {\n        throw new Error('Port is not open');\n      }\n\n      logger('waiting for readable because of code:', err.code);\n      await readable(this);\n      return this.read(buffer, offset, length);\n    }\n\n    const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n    err.code === 'ENXIO' || // No such device or address probably usb disconnect\n    err.code === 'UNKNOWN' || err.errno === -1; // generic error\n\n    if (disconnectError) {\n      err.disconnect = true;\n      logger('disconnecting', err);\n    }\n\n    throw err;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}