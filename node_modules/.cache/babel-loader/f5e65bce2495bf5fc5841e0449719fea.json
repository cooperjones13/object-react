{"ast":null,"code":"const _require = require('stream'),\n      Transform = _require.Transform;\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n * @summary To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n * @example\nconst SerialPort = require('serialport')\nconst Delimiter = require('@serialport/parser-delimiter')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Delimiter({ delimiter: '\\n' }))\nparser.on('data', console.log)\n */\n\n\nclass DelimiterParser extends Transform {\n  constructor(options = {}) {\n    super(options);\n\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n\n    this.includeDelimiter = options.includeDelimiter !== undefined ? options.includeDelimiter : false;\n    this.delimiter = Buffer.from(options.delimiter);\n    this.buffer = Buffer.alloc(0);\n  }\n\n  _transform(chunk, encoding, cb) {\n    let data = Buffer.concat([this.buffer, chunk]);\n    let position;\n\n    while ((position = data.indexOf(this.delimiter)) !== -1) {\n      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));\n      data = data.slice(position + this.delimiter.length);\n    }\n\n    this.buffer = data;\n    cb();\n  }\n\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n\n}\n\nmodule.exports = DelimiterParser;","map":null,"metadata":{},"sourceType":"script"}